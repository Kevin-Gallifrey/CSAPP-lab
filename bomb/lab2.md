# phase_1
直接比较输入与字符串是否相等。  

`strings_not_equal`：  
输入字符串首地址在`%rdi`中，用于比较的字符串首地址在`%rsi`中。  
两次调用`string_length`，分别得到输入字符串长度`%r12d`和比较字符串长度`%eax`。随后比较两者大小，若不同，则直接返回1。  
之后就是逐一比较两个字符串中的内容。  
`movzbl (%rbx),%eax`和`test   %al,%al`用于检查是否到了字符串末尾。  

`string_length`：  
string的首地址在`%rdi`中。  
`cmpb   $0x0,(%rdi)`用于检查rdi是否指向字符串末位的`\0`，判断字符串是否结束。

# phase_2
比较6个数字是否一致。这6个数字分别存在`(%rsp), 0x4(%rsp), 0x8(%rsp), 0xc(%rsp), 0x10(%rsp), 0x14(%rsp)`。在判断时`%rbx`指向它们，每次循环加4。`%rbp`用于判断是否结束。  
`mov    -0x4(%rbx),%eax`将前一个数放%eax，`add    %eax,%eax`将结果×2，`cmp    %eax,(%rbx)`比较大小。说明后一个数是前一个数的2倍。  

`read_six_numbers`：  
读取6个数字，其中`__isoc99_sscanf@plt`可以看作是scanf，读取输入的数。返回结果`%eax`表示读到的输入个数，若小于等于5，则直接爆炸。前面一系列赋值操作用于表明存放数据的地址。  
`mov    $0x4025c3,%esi`是将格式写入，`0x4025c3: "%d %d %d %d %d %d"`，这就是读取时的格式，是6个整型。

# phase_3
通过查看0x4025cf的内容，发现format是`"%d %d"`。两个数分别存于`0x8(%rsp), 0xc(%rsp)`。后面是一个switch分支，跳转地址是`*0x402470(,%rax,8)`，查看内存空间就能得到对应的地址。不同的分支会赋不同的值给`%eax`，最后要求`0xc(%rsp)`和`%eax`的值相同。两个输入的选择有多种，只要匹配就行。

# phase_4
同样是输入两个整数，分别存于`0x8(%rsp), 0xc(%rsp)`。其中`0x8(%rsp)`作为参数放在`%rdi`中传入`func4`。`0x8(%rsp)`要小于等于0xe，否则直接爆炸。`func4`与`0xc(%rsp)`没有关系，最后的判断中保证`0xc(%rsp)`等于0即可。  

`func4`：  
三个参数分别是`%rdx, %rsi, %rdi`，其中`%rdx`初始化为0xe，`%rsi`初始化为0。  
先根据`%rdx`和%`rsi`计算得到`%ecx`，若`%ecx`大于`%rdi`，`%rdx = %ecx - 1`，继续递归；若`%ecx`小于`%rdi`，`%rsi = %ecx + 1`，继续递归；若`%ecx`等于`%rdi`，返回0。  
最后需要返回0。`%rdi`有多个值，7、3、1、0均可。

# phase_5
`string_length`的输出应该是6，表明字符串长度为6。后面有一个循环，循环次数为6，用`%rax`计数，每次都会取出一个字符，与0xf按位与（`and    $0xf,%edx`），并根据结果从0x4024b0为首地址的内存空间取出一个字符（`movzbl 0x4024b0(%rdx),%edx`），并放入栈中（`mov    %dl,0x10(%rsp,%rax,1)`）。  
最后进行字符串比较，分别是栈中的字符串和内存特定地址中的字符串。  
输入的字符串是作为偏移量，根据结果反推偏移量即可。由于偏移量只取了低4位，所以高4位可以任意。在ASCII码中a对应0x61，z对应0x7a。

# phase_6
用`read_six_numbers`读取6个整数，放在`(%rsp), 0x4(%rsp), 0x8(%rsp), 0xc(%rsp), 0x10(%rsp), 0x14(%rsp)`。  
双重循环，保证这6个数都小于等于6，且互不相同。  
用7减去这6个数，并存于原来的位置。  
根据新的6个数，将其减1作为偏移量，从内存地址0x6032d0开始寻找值，并存于`0x20(%rsp), 0x28(%rsp), 0x30(%rsp), 0x38(%rsp), 0x40(%rsp), 0x48(%rsp)`。  
内存中从0x6032d0开始的6*2*8个字节存放的链表，共6个节点，每个节点前8个字节是值（值是整型，取4个字节），后8个字节是next指针。  
按照栈中的顺序，调整链表的次序。最终链表的次序需要满足前一个节点的值大于等于后一个节点的值。

# secret_phase
隐藏关！  
在`phase_defused`中有调用`secret_phase`的指令。  

`phase_defused`：  
`cmpl   $0x6,0x202181(%rip)`对输入计数，只有前6个phase都解决了之后，才能继续。只有`phase_6`的`phase_defused`才会触发隐藏关卡。  
调用了`__isoc99_sscanf@plt`读取输入。查看`%esi`指向内容，格式为`"%d %d %s"`。查看`%edi`指向内容，为`"7 0"`，这是`phase_4`输入的内容，在其后面加上一个特定字符串即可开启隐藏关。  
利用`strings_not_equal`，查看比较字符串内容，可以得到需要输入的字符串。  

`secret_phase`：  
`read_line`读取输入。`strtol@plt`将输入字符串转成long，存在`%rax`中。判断`%rax - 1 <= 0x3e8`，若是则进入`fun7`，否则爆炸。最后要求`fun7`返回结果为2。  

`fun7`：  
入参`%rdi = 0x6030f0, %rsi = 输入值`。`%rdi`中存的是地址。先判断`%rdi`是否为0，若是返回全1。判断`%rdi`的值与`%rsi`的大小，进行相应的操作。
```
int fun7(rdi, rsi)
{
    if (*rdi == 0)
        return 0xffffffff;
    if (*rdi > rsi)
    {
        rdi = *(rdi + 0x8);
        a = fun7(rdi, rsi);
        a = a * 2;
    }
    else if (*rdi < rsi)
    {
        rdi = *(rdi + 0x10);
        a = fun7(rdi, rsi);
        a = a * 2 + 1;
    }
    else
        a = 0;
    return a;
}
```
`%rdi`指向的是一颗二叉树，一个节点占4*8个字节，第一个8B是value，第二个8B指向左子树，第三个8B指向右子树，第四个8B是空的，这是为了数据对齐。这是一颗二叉搜索树，且最大值为0x3e9，这也是为什么一开始会出现判断`%rax - 1 <= 0x3e8`的原因。